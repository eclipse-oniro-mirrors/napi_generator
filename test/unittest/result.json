{
    "toolsParam": {
        "removeExplains": "\"\\ndeclare namespace napitest {\\ninterface Human {\\nname: string;\\nage: number;\\n}\\ninterface TestClass1 {\\nahuman: Human;\\nnum1: number;\\nstr1: string;\\nnums: Array<number>;\\nstrs: Array<string>;\\nmans: Array<Human>;\\nif_direct(v1: string): string;\\nif_callback(v1: string, cb: Callback<string>): string;\\nif_async(v1: string, cb: AsyncCallback<string>): string;\\n}\\nfunction fun2(v2: string, numcc: Array<number>, mancc: Human): Array<Human>;\\nfunction fun3(v2: string, cb: Callback<string>): void;\\nfunction fun4(v2: string, cb: AsyncCallback<string>): void;\\nnamespace Space3 {\\nfunction fun3(v3: string): string;\\ninterface TestClass2 {\\nhaha: number;\\n}\\nnamespace Space4 {\\nfunction fun3(v3: string): string;\\ninterface TestClass3 {\\nhoho: number;\\nadd(v1: Array<number>): number;\\n}\\n}\\n}\\n}\\nexport default napitest;\"",
        "removeEmptyLine": "\"\\ndeclare namespace napitest {\\ninterface Human {\\nname: string;\\nage: number;\\n}\\ninterface TestClass1 {\\nahuman: Human;\\nnum1: number;\\nstr1: string;\\nnums: Array<number>;\\nstrs: Array<string>;\\nmans: Array<Human>;\\nif_direct(v1: string): string;\\nif_callback(v1: string, cb: Callback<string>): string;\\nif_async(v1: string, cb: AsyncCallback<string>): string;\\n}\\nfunction fun2(v2: string, numcc: Array<number>, mancc: Human): Array<Human>;\\nfunction fun3(v2: string, cb: Callback<string>): void;\\nfunction fun4(v2: string, cb: AsyncCallback<string>): void;\\nnamespace Space3 {\\nfunction fun3(v3: string): string;\\ninterface TestClass2 {\\nhaha: number;\\n}\\nnamespace Space4 {\\nfunction fun3(v3: string): string;\\ninterface TestClass3 {\\nhoho: number;\\nadd(v1: Array<number>): number;\\n}\\n}\\n}\\n}\\nexport default napitest;\"",
        "replaceAll": "\"\\nstruct if_direct_value_struct {[valueIn]\\n    \\n    [valueOut]\\n};\\n\\n[static_define]napi_value if_direct_middle(napi_env env, napi_callback_info info)\\n{\\n    XNapiTool *pxt = std::make_unique<XNapiTool>(env, info).release();\\n    if (pxt->IsFailed())\\n    {\\n        napi_value err = pxt->GetError();\\n        delete pxt;\\n        return err;\\n    }\\n    [unwarp_instance]\\n\\n    struct [funcName]_value_struct *vio=new [funcName]_value_struct();\\n    \\n    [valueCheckout]\\n\\n    [callFunc]\\n\\n    [valuePackage]\\n\\n    delete vio;\\n    if (pxt->IsFailed())\\n        result = pxt->GetError();\\n    delete pxt;// release\\n    return result;\\n}\"",
        "checkOutBody": "\"declare namespace napitest {\\ninterface Human {\\nname: string;\\nage: number;\\n}\\ninterface TestClass1 {\\nahuman: Human;\\nnum1: number;\\nstr1: string;\\nnums: Array<number>;\\nstrs: Array<string>;\\nmans: Array<Human>;\\nif_direct(v1: string): string;\\nif_callback(v1: string, cb: Callback<string>): string;\\nif_async(v1: string, cb: AsyncCallback<string>): string;\\n}\\nfunction fun2(v2: string, numcc: Array<number>, mancc: Human): Array<Human>;\\nfunction fun3(v2: string, cb: Callback<string>): void;\\nfunction fun4(v2: string, cb: AsyncCallback<string>): void;\\nnamespace Space3 {\\nfunction fun3(v3: string): string;\\ninterface TestClass2 {\\nhaha: number;\\n}\\nnamespace Space4 {\\nfunction fun3(v3: string): string;\\ninterface TestClass3 {\\nhoho: number;\\nadd(v1: Array<number>): number;\\n}\\n}\\n}\\n}\\nexport default napitest;\"",
        "analyzeFileParam": "\"declare namespace napitest {\\ninterface Human {\\nname: string;\\nage: number;\\n}\\ninterface TestClass1 {\\nahuman: Human;\\nnum1: number;\\nstr1: string;\\nnums: Array<number>;\\nstrs: Array<string>;\\nmans: Array<Human>;\\nif_direct(v1: string): string;\\nif_callback(v1: string, cb: Callback<string>): string;\\nif_async(v1: string, cb: AsyncCallback<string>): string;\\n}\\nfunction fun2(v2: string, numcc: Array<number>, mancc: Human): Array<Human>;\\nfunction fun3(v2: string, cb: Callback<string>): void;\\nfunction fun4(v2: string, cb: AsyncCallback<string>): void;\\nnamespace Space3 {\\nfunction fun3(v3: string): string;\\ninterface TestClass2 {\\nhaha: number;\\n}\\nnamespace Space4 {\\nfunction fun3(v3: string): string;\\ninterface TestClass3 {\\nhoho: number;\\nadd(v1: Array<number>): number;\\n}\\n}\\n}\\n}\\nexport default napitest;\""
    },
    "tools": {
        "removeExplains": "\"\\\"\\\\\\\"\\\\\\\\ndeclare namespace napitest {\\\\\\\\ninterface Human {\\\\\\\\nname: string;\\\\\\\\nage: number;\\\\\\\\n}\\\\\\\\ninterface TestClass1 {\\\\\\\\nahuman: Human;\\\\\\\\nnum1: number;\\\\\\\\nstr1: string;\\\\\\\\nnums: Array<number>;\\\\\\\\nstrs: Array<string>;\\\\\\\\nmans: Array<Human>;\\\\\\\\nif_direct(v1: string): string;\\\\\\\\nif_callback(v1: string, cb: Callback<string>): string;\\\\\\\\nif_async(v1: string, cb: AsyncCallback<string>): string;\\\\\\\\n}\\\\\\\\nfunction fun2(v2: string, numcc: Array<number>, mancc: Human): Array<Human>;\\\\\\\\nfunction fun3(v2: string, cb: Callback<string>): void;\\\\\\\\nfunction fun4(v2: string, cb: AsyncCallback<string>): void;\\\\\\\\nnamespace Space3 {\\\\\\\\nfunction fun3(v3: string): string;\\\\\\\\ninterface TestClass2 {\\\\\\\\nhaha: number;\\\\\\\\n}\\\\\\\\nnamespace Space4 {\\\\\\\\nfunction fun3(v3: string): string;\\\\\\\\ninterface TestClass3 {\\\\\\\\nhoho: number;\\\\\\\\nadd(v1: Array<number>): number;\\\\\\\\n}\\\\\\\\n}\\\\\\\\n}\\\\\\\\n}\\\\\\\\nexport default napitest;\\\\\\\"\\\"\"",
        "removeEmptyLine": "\"\\\"\\\\\\\"\\\\\\\\ndeclare namespace napitest {\\\\\\\\ninterface Human {\\\\\\\\nname: string;\\\\\\\\nage: number;\\\\\\\\n}\\\\\\\\ninterface TestClass1 {\\\\\\\\nahuman: Human;\\\\\\\\nnum1: number;\\\\\\\\nstr1: string;\\\\\\\\nnums: Array<number>;\\\\\\\\nstrs: Array<string>;\\\\\\\\nmans: Array<Human>;\\\\\\\\nif_direct(v1: string): string;\\\\\\\\nif_callback(v1: string, cb: Callback<string>): string;\\\\\\\\nif_async(v1: string, cb: AsyncCallback<string>): string;\\\\\\\\n}\\\\\\\\nfunction fun2(v2: string, numcc: Array<number>, mancc: Human): Array<Human>;\\\\\\\\nfunction fun3(v2: string, cb: Callback<string>): void;\\\\\\\\nfunction fun4(v2: string, cb: AsyncCallback<string>): void;\\\\\\\\nnamespace Space3 {\\\\\\\\nfunction fun3(v3: string): string;\\\\\\\\ninterface TestClass2 {\\\\\\\\nhaha: number;\\\\\\\\n}\\\\\\\\nnamespace Space4 {\\\\\\\\nfunction fun3(v3: string): string;\\\\\\\\ninterface TestClass3 {\\\\\\\\nhoho: number;\\\\\\\\nadd(v1: Array<number>): number;\\\\\\\\n}\\\\\\\\n}\\\\\\\\n}\\\\\\\\n}\\\\\\\\nexport default napitest;\\\\\\\"\\\"\"",
        "replaceAll": "\"\\\"\\\\\\\"\\\\\\\\if_directstrif_directif_directt iif_direct_dirif_directif_directt_vif_directlif_directif_direct_strif_directif_directt {[vif_directlif_directif_directIif_direct]\\\\\\\\if_direct    \\\\\\\\if_direct    [vif_directlif_directif_directOif_directt]\\\\\\\\if_direct};\\\\\\\\if_direct\\\\\\\\if_direct[stif_directtiif_direct_dif_directif_directiif_directif_direct]if_directif_directpi_vif_directlif_directif_direct iif_direct_dirif_directif_directt_if_directiddlif_direct(if_directif_directpi_if_directif_directv if_directif_directv, if_directif_directpi_if_directif_directllbif_directif_directk_iif_directif_directo iif_directif_directo)\\\\\\\\if_direct{\\\\\\\\if_direct    Xif_directif_directpiTool *pxt = std::if_directif_directkif_direct_if_directif_directiqif_directif_direct<Xif_directif_directpiTool>(if_directif_directv, iif_directif_directo).rif_directlif_directif_directsif_direct();\\\\\\\\if_direct    iif_direct (pxt->IsFif_directilif_directd())\\\\\\\\if_direct    {\\\\\\\\if_direct        if_directif_directpi_vif_directlif_directif_direct if_directrr = pxt->Gif_directtError();\\\\\\\\if_direct        dif_directlif_directtif_direct pxt;\\\\\\\\if_direct        rif_directtif_directrif_direct if_directrr;\\\\\\\\if_direct    }\\\\\\\\if_direct    [if_directif_directwif_directrp_iif_directstif_directif_directif_directif_direct]\\\\\\\\if_direct\\\\\\\\if_direct    strif_directif_directt [if_directif_directif_directif_directif_directif_directif_directif_direct]_vif_directlif_directif_direct_strif_directif_directt *vio=if_directif_directw [if_directif_directif_directif_directif_directif_directif_directif_direct]_vif_directlif_directif_direct_strif_directif_directt();\\\\\\\\if_direct    \\\\\\\\if_direct    [vif_directlif_directif_directChif_directif_directkoif_directt]\\\\\\\\if_direct\\\\\\\\if_direct    [if_directif_directllFif_directif_directif_direct]\\\\\\\\if_direct\\\\\\\\if_direct    [vif_directlif_directif_directPif_directif_directkif_directgif_direct]\\\\\\\\if_direct\\\\\\\\if_direct    dif_directlif_directtif_direct vio;\\\\\\\\if_direct    iif_direct (pxt->IsFif_directilif_directd())\\\\\\\\if_direct        rif_directsif_directlt = pxt->Gif_directtError();\\\\\\\\if_direct    dif_directlif_directtif_direct pxt;// rif_directlif_directif_directsif_direct\\\\\\\\if_direct    rif_directtif_directrif_direct rif_directsif_directlt;\\\\\\\\if_direct}\\\\\\\"\\\"\"",
        "checkOutBody": "null"
    },
    "Analyze": {
        "analyzeFile": "{\"exportDefault\":[],\"exports\":[],\"declareType\":[],\"declareFunction\":[],\"declareNamespace\":[],\"declareInterface\":[],\"declareLicense\":[]}",
        "analyzeFunction": "{\"name\":\"a\",\"type\":1,\"value\":[{\"name\":\"b\",\"type\":\"NUMBER_TYPE_1\"}],\"ret\":\"string\"}",
        "analyzeInterface": "{\"value\":[{\"name\":\"name\",\"type\":\"string\"}],\"function\":[]}",
        "analyzeNamespace": "{\"exports\":[],\"enum\":[],\"const\":[],\"type\":[],\"function\":[],\"interface\":[],\"class\":[],\"namespace\":[]}",
        "analyzeParams": "[[],1]",
        "analyzeReturn": "[\"string\",false]"
    },
    "Generate": {
        "generateFunctionAsync": "[\"\\nstruct if_async_value_struct {\\n    std::string in0;\\n    \\n    std::string out;\\n};\\n\\nstatic void if_async_execute(XNapiTool *pxt, void *data)\\n{\\n    if_async_value_struct *vio = (if_async_value_struct *)data;\\n    TestClass1 *pInstance = (TestClass1 *)pxt->GetAsyncInstance();\\n\\n    pInstance->if_async(vio->in0, vio->out);\\n}\\n\\nstatic void if_async_complete(XNapiTool *pxt, void *data)\\n{\\n    if_async_value_struct *vio = (if_async_value_struct *)data;\\n    \\n    napi_value result = nullptr;\\n    result = pxt->SwapC2JsUtf8(vio->out.c_str());\\n    \\n    {\\n        napi_value args[1] = {result};\\n        pxt->FinishAsync(1, args);\\n    }\\n\\n    delete vio;\\n}\\n\\nstatic napi_value if_async_middle(napi_env env, napi_callback_info info)\\n{\\n    XNapiTool *pxt = std::make_unique<XNapiTool>(env, info).release();\\n    if (pxt->IsFailed()) {\\n        napi_value err = pxt->GetError();\\n        delete pxt;\\n        return err;\\n    }\\n    pxt->SetAsyncInstance(pxt->UnWarpInstance());\\n\\n    struct if_async_value_struct *vio = new if_async_value_struct();\\n    \\n    pxt->SwapJs2CUtf8(pxt->GetArgv(0), vio->in0);\\n\\n    \\n    napi_value result = pxt->StartAsync(if_async_execute, vio, if_async_complete, pxt->GetArgc() == 2 ? pxt->GetArgv(1) : nullptr);\\n\\n    if (pxt->IsFailed()) {\\n        result = pxt->GetError();\\n    }\\n    return result;\\n}\",\"\\nbool if_async(std::string &v1, std::string &out);\",\"\\nbool TestClass1::if_async(std::string &v1, std::string &out)\\n{\\n    return true;\\n}\\n\"]",
        "generateFunctionDirect": "[\"\\nstruct if_async_value_struct {\\n    std::string in0;\\n    \\n    std::string out;\\n};\\n\\nstatic napi_value if_async_middle(napi_env env, napi_callback_info info)\\n{\\n    XNapiTool *pxt = std::make_unique<XNapiTool>(env, info).release();\\n    if (pxt->IsFailed()) {\\n        napi_value err = pxt->GetError();\\n        delete pxt;\\n        return err;\\n    }\\n    TestClass1 *pInstance = (TestClass1 *)pxt->UnWarpInstance();\\n\\n    struct if_async_value_struct *vio = new if_async_value_struct();\\n    \\n    pxt->SwapJs2CUtf8(pxt->GetArgv(0), vio->in0);\\n\\n    pInstance->if_async(vio->in0, vio->out);\\n\\n    napi_value result = nullptr;\\n    result = pxt->SwapC2JsUtf8(vio->out.c_str());\\n\\n    delete vio;\\n    if (pxt->IsFailed()) {\\n        result = pxt->GetError();\\n    }\\n    delete pxt; // release\\n    return result;\\n}\",\"\\nbool if_async(std::string &v1, std::string &out);\",\"\\nbool TestClass1::if_async(std::string &v1, std::string &out)\\n{\\n    return true;\\n}\\n\"]",
        "generateFunctionSync": "[\"\\nstruct if_callback_value_struct {\\n    std::string in0;\\n    \\n    std::string out;\\n};\\n\\nstatic napi_value if_callback_middle(napi_env env, napi_callback_info info)\\n{\\n    XNapiTool *pxt = std::make_unique<XNapiTool>(env, info).release();\\n    if (pxt->IsFailed()) {\\n        napi_value err = pxt->GetError();\\n        delete pxt;\\n        return err;\\n    }\\n    TestClass1 *pInstance = (TestClass1 *)pxt->UnWarpInstance();\\n\\n    struct if_callback_value_struct *vio = new if_callback_value_struct();\\n    \\n    pxt->SwapJs2CUtf8(pxt->GetArgv(0), vio->in0);\\n\\n    pInstance->if_callback(vio->in0, vio->out);\\n\\n    napi_value result = nullptr;\\n    result = pxt->SwapC2JsUtf8(vio->out.c_str());\\n\\n    {\\n        napi_value args[1] = {result};\\n        pxt->SyncCallBack(pxt->GetArgv(1), 1, args);\\n    }\\n    result = pxt->UndefinedValue();\\n\\n    delete vio;\\n    if (pxt->IsFailed()) {\\n        result = pxt->GetError();\\n    }\\n    delete pxt; // release\\n    return result;\\n}\",\"\\nbool if_callback(std::string &v1, std::string &out);\",\"\\nbool TestClass1::if_callback(std::string &v1, std::string &out)\\n{\\n    return true;\\n}\\n\"]",
        "generateInterface": "{\"implH\":\"\\nclass a {\\npublic:\\n};\",\"implCpp\":\"\",\"middleBody\":\"\\nclass a_middle {\\npublic:\\nstatic napi_value constructor(napi_env env, napi_callback_info info)\\n{\\n    XNapiTool *pxt = new XNapiTool(env, info);\\n\\n    a *p = new a();\\n\\n    napi_value thisvar = pxt->WrapInstance(p, release);\\n\\n    return thisvar;\\n}\\nstatic void release(void *p)\\n{\\n    a *p2 = (a *)p;\\n    delete p2;\\n}\\n\\n};\",\"middleInit\":\"{\\n    std::map<const char *,std::map<const char *,napi_callback>> valueList;\\n    std::map<const char *, napi_callback> funcList;\\n    pxt->DefineClass(\\\"a\\\", [object Object]a_middle::constructor, valueList ,funcList);\\n}\\n\"}",
        "generateNamespace": "{\"implH\":\"namespace napitest {\\nclass Human {\\npublic:\\n    std::string name;\\n    NUMBER_TYPE_1 age;\\n};\\nclass TestClass1 {\\npublic:\\n    Human ahuman;\\n    NUMBER_TYPE_2 num1;\\n    std::string str1;\\n    std::vector<NUMBER_TYPE_3> nums;\\n    std::vector<std::string> strs;\\n    std::vector<Human> mans;\\nbool if_direct(std::string &v1, std::string &out);\\nbool if_callback(std::string &v1, std::string &out);\\nbool if_async(std::string &v1, std::string &out);\\n};\\nbool fun2(std::string &v2, std::vector<NUMBER_TYPE_4> &numcc, Human &mancc, std::vector<Human> &out);\\nbool fun3(std::string &v2, std::string &out);\\nbool fun4(std::string &v2, std::string &out);namespace Space3 {\\nclass TestClass2 {\\npublic:\\n    NUMBER_TYPE_5 haha;\\n};\\nbool fun3(std::string &v3, std::string &out);namespace Space4 {\\nclass TestClass3 {\\npublic:\\n    NUMBER_TYPE_6 hoho;\\nbool add(std::vector<NUMBER_TYPE_7> &v1, NUMBER_TYPE_8 &out);\\n};\\nbool fun3(std::string &v3, std::string &out);\\n}\\n}\\n}\",\"implCpp\":\"namespace napitest {\\nbool TestClass1::if_direct(std::string &v1, std::string &out)\\n{\\n    return true;\\n}\\n\\nbool TestClass1::if_callback(std::string &v1, std::string &out)\\n{\\n    return true;\\n}\\n\\nbool TestClass1::if_async(std::string &v1, std::string &out)\\n{\\n    return true;\\n}\\n\\nbool fun2(std::string &v2, std::vector<NUMBER_TYPE_4> &numcc, Human &mancc, std::vector<Human> &out)\\n{\\n    return true;\\n}\\n\\nbool fun3(std::string &v2, std::string &out)\\n{\\n    return true;\\n}\\n\\nbool fun4(std::string &v2, std::string &out)\\n{\\n    return true;\\n}\\nnamespace Space3 {\\nbool fun3(std::string &v3, std::string &out)\\n{\\n    return true;\\n}\\nnamespace Space4 {\\nbool TestClass3::add(std::vector<NUMBER_TYPE_7> &v1, NUMBER_TYPE_8 &out)\\n{\\n    return true;\\n}\\n\\nbool fun3(std::string &v3, std::string &out)\\n{\\n    return true;\\n}\\n}}}\",\"middleBody\":\"namespace napitest {\\nclass Human_middle {\\npublic:\\nstatic napi_value constructor(napi_env env, napi_callback_info info)\\n{\\n    XNapiTool *pxt = new XNapiTool(env, info);\\n\\n    Human *p = new Human();\\n\\n    napi_value thisvar = pxt->WrapInstance(p, release);\\n\\n    return thisvar;\\n}\\nstatic void release(void *p)\\n{\\n    Human *p2 = (Human *)p;\\n    delete p2;\\n}\\n\\n    static napi_value getvalue_name(napi_env env, napi_callback_info info)\\n    {\\n        XNapiTool *pxt = std::make_unique<XNapiTool>(env, info).release();\\n        Human *p = (Human *)pxt->UnWarpInstance();\\n        napi_value result;\\n        result = pxt->SwapC2JsUtf8(p->name.c_str());\\n        delete pxt;\\n        return result;\\n    }\\n    static napi_value setvalue_name(napi_env env, napi_callback_info info)\\n    {\\n        std::shared_ptr<XNapiTool> pxt = std::make_shared<XNapiTool>(env, info);\\n        Human *p = (Human *)pxt->UnWarpInstance();\\n        pxt->SwapJs2CUtf8(pxt->GetArgv(0), p->name);\\n        return nullptr;\\n    }\\n\\n    static napi_value getvalue_age(napi_env env, napi_callback_info info)\\n    {\\n        XNapiTool *pxt = std::make_unique<XNapiTool>(env, info).release();\\n        Human *p = (Human *)pxt->UnWarpInstance();\\n        napi_value result;\\n        result = NUMBER_C_2_JS(pxt, p->age);\\n        delete pxt;\\n        return result;\\n    }\\n    static napi_value setvalue_age(napi_env env, napi_callback_info info)\\n    {\\n        std::shared_ptr<XNapiTool> pxt = std::make_shared<XNapiTool>(env, info);\\n        Human *p = (Human *)pxt->UnWarpInstance();\\n        NUMBER_JS_2_C(pxt->GetArgv(0),NUMBER_TYPE_1,p->age);\\n        return nullptr;\\n    }\\n\\n};\\nclass TestClass1_middle {\\npublic:\\nstatic napi_value constructor(napi_env env, napi_callback_info info)\\n{\\n    XNapiTool *pxt = new XNapiTool(env, info);\\n\\n    TestClass1 *p = new TestClass1();\\n\\n    napi_value thisvar = pxt->WrapInstance(p, release);\\n\\n    return thisvar;\\n}\\nstatic void release(void *p)\\n{\\n    TestClass1 *p2 = (TestClass1 *)p;\\n    delete p2;\\n}\\n\\n    static napi_value getvalue_ahuman(napi_env env, napi_callback_info info)\\n    {\\n        XNapiTool *pxt = std::make_unique<XNapiTool>(env, info).release();\\n        TestClass1 *p = (TestClass1 *)pxt->UnWarpInstance();\\n        napi_value result;\\n        {\\nnapi_value tnv1 = nullptr;\\ntnv1 = pxt->SwapC2JsUtf8(p->ahuman.name.c_str());\\npxt->SetValueProperty(result,\\\"name\\\",tnv1);\\n}{\\nnapi_value tnv1 = nullptr;\\ntnv1 = NUMBER_C_2_JS(pxt, p->ahuman.age);\\npxt->SetValueProperty(result,\\\"age\\\",tnv1);\\n}\\n        delete pxt;\\n        return result;\\n    }\\n    static napi_value setvalue_ahuman(napi_env env, napi_callback_info info)\\n    {\\n        std::shared_ptr<XNapiTool> pxt = std::make_shared<XNapiTool>(env, info);\\n        TestClass1 *p = (TestClass1 *)pxt->UnWarpInstance();\\n        napi_value tnv1 = pxt->GetValueProperty(pxt->GetArgv(0), \\\"name\\\");\\n    if(tnv1!=nullptr){pxt->SwapJs2CUtf8(tnv1,p->ahuman.name);}napi_value tnv2 = pxt->GetValueProperty(pxt->GetArgv(0), \\\"age\\\");\\n    if(tnv2!=nullptr){NUMBER_JS_2_C(tnv2,NUMBER_TYPE_1,p->ahuman.age);}\\n        return nullptr;\\n    }\\n\\n    static napi_value getvalue_num1(napi_env env, napi_callback_info info)\\n    {\\n        XNapiTool *pxt = std::make_unique<XNapiTool>(env, info).release();\\n        TestClass1 *p = (TestClass1 *)pxt->UnWarpInstance();\\n        napi_value result;\\n        result = NUMBER_C_2_JS(pxt, p->num1);\\n        delete pxt;\\n        return result;\\n    }\\n    static napi_value setvalue_num1(napi_env env, napi_callback_info info)\\n    {\\n        std::shared_ptr<XNapiTool> pxt = std::make_shared<XNapiTool>(env, info);\\n        TestClass1 *p = (TestClass1 *)pxt->UnWarpInstance();\\n        NUMBER_JS_2_C(pxt->GetArgv(0),NUMBER_TYPE_2,p->num1);\\n        return nullptr;\\n    }\\n\\n    static napi_value getvalue_str1(napi_env env, napi_callback_info info)\\n    {\\n        XNapiTool *pxt = std::make_unique<XNapiTool>(env, info).release();\\n        TestClass1 *p = (TestClass1 *)pxt->UnWarpInstance();\\n        napi_value result;\\n        result = pxt->SwapC2JsUtf8(p->str1.c_str());\\n        delete pxt;\\n        return result;\\n    }\\n    static napi_value setvalue_str1(napi_env env, napi_callback_info info)\\n    {\\n        std::shared_ptr<XNapiTool> pxt = std::make_shared<XNapiTool>(env, info);\\n        TestClass1 *p = (TestClass1 *)pxt->UnWarpInstance();\\n        pxt->SwapJs2CUtf8(pxt->GetArgv(0), p->str1);\\n        return nullptr;\\n    }\\n\\n    static napi_value getvalue_nums(napi_env env, napi_callback_info info)\\n    {\\n        XNapiTool *pxt = std::make_unique<XNapiTool>(env, info).release();\\n        TestClass1 *p = (TestClass1 *)pxt->UnWarpInstance();\\n        napi_value result;\\n        uint32_t len1=p->nums.size();\\n    for(uint32_t i=0;i<len1;i++) {\\n        napi_value tnv1 = nullptr;\\n        tnv1 = NUMBER_C_2_JS(pxt,p->nums[i]);\\n        pxt->SetArrayElement(result, i, tnv1);\\n    }\\n        delete pxt;\\n        return result;\\n    }\\n    static napi_value setvalue_nums(napi_env env, napi_callback_info info)\\n    {\\n        std::shared_ptr<XNapiTool> pxt = std::make_shared<XNapiTool>(env, info);\\n        TestClass1 *p = (TestClass1 *)pxt->UnWarpInstance();\\n            uint32_t len3=pxt->GetArrayLength(pxt->GetArgv(0));\\n    for(uint32_t i3=0;i3<len3;i3++) {\\n        NUMBER_TYPE_3 tt3;\\n        NUMBER_JS_2_C(pxt->GetArrayElement(pxt->GetArgv(0),i3),NUMBER_TYPE_3,tt3);\\n        p->nums.push_back(tt3);\\n    }\\n        return nullptr;\\n    }\\n\\n    static napi_value getvalue_strs(napi_env env, napi_callback_info info)\\n    {\\n        XNapiTool *pxt = std::make_unique<XNapiTool>(env, info).release();\\n        TestClass1 *p = (TestClass1 *)pxt->UnWarpInstance();\\n        napi_value result;\\n        uint32_t len1=p->strs.size();\\n    for(uint32_t i=0;i<len1;i++) {\\n        napi_value tnv1 = nullptr;\\n        tnv1 = pxt->SwapC2JsUtf8(p->strs[i].c_str());\\n        pxt->SetArrayElement(result, i, tnv1);\\n    }\\n        delete pxt;\\n        return result;\\n    }\\n    static napi_value setvalue_strs(napi_env env, napi_callback_info info)\\n    {\\n        std::shared_ptr<XNapiTool> pxt = std::make_shared<XNapiTool>(env, info);\\n        TestClass1 *p = (TestClass1 *)pxt->UnWarpInstance();\\n            uint32_t len4=pxt->GetArrayLength(pxt->GetArgv(0));\\n    for(uint32_t i4=0;i4<len4;i4++) {\\n        std::string tt4;\\n        pxt->SwapJs2CUtf8(pxt->GetArrayElement(pxt->GetArgv(0),i4), tt4);\\n        p->strs.push_back(tt4);\\n    }\\n        return nullptr;\\n    }\\n\\n    static napi_value getvalue_mans(napi_env env, napi_callback_info info)\\n    {\\n        XNapiTool *pxt = std::make_unique<XNapiTool>(env, info).release();\\n        TestClass1 *p = (TestClass1 *)pxt->UnWarpInstance();\\n        napi_value result;\\n        uint32_t len1=p->mans.size();\\n    for(uint32_t i=0;i<len1;i++) {\\n        napi_value tnv1 = nullptr;\\n        {\\nnapi_value tnv2 = nullptr;\\ntnv2 = pxt->SwapC2JsUtf8(p->mans[i].name.c_str());\\npxt->SetValueProperty(tnv1,\\\"name\\\",tnv2);\\n}{\\nnapi_value tnv2 = nullptr;\\ntnv2 = NUMBER_C_2_JS(pxt, p->mans[i].age);\\npxt->SetValueProperty(tnv1,\\\"age\\\",tnv2);\\n}\\n        pxt->SetArrayElement(result, i, tnv1);\\n    }\\n        delete pxt;\\n        return result;\\n    }\\n    static napi_value setvalue_mans(napi_env env, napi_callback_info info)\\n    {\\n        std::shared_ptr<XNapiTool> pxt = std::make_shared<XNapiTool>(env, info);\\n        TestClass1 *p = (TestClass1 *)pxt->UnWarpInstance();\\n            uint32_t len5=pxt->GetArrayLength(pxt->GetArgv(0));\\n    for(uint32_t i5=0;i5<len5;i5++) {\\n        Human tt5;\\n        napi_value tnv6 = pxt->GetValueProperty(pxt->GetArrayElement(pxt->GetArgv(0),i5), \\\"name\\\");\\n    if(tnv6!=nullptr){pxt->SwapJs2CUtf8(tnv6,tt5.name);}napi_value tnv7 = pxt->GetValueProperty(pxt->GetArrayElement(pxt->GetArgv(0),i5), \\\"age\\\");\\n    if(tnv7!=nullptr){NUMBER_JS_2_C(tnv7,NUMBER_TYPE_1,tt5.age);}\\n        p->mans.push_back(tt5);\\n    }\\n        return nullptr;\\n    }\\n\\nstruct if_direct_value_struct {\\n    std::string in0;\\n    \\n    std::string out;\\n};\\n\\nstatic napi_value if_direct_middle(napi_env env, napi_callback_info info)\\n{\\n    XNapiTool *pxt = std::make_unique<XNapiTool>(env, info).release();\\n    if (pxt->IsFailed()) {\\n        napi_value err = pxt->GetError();\\n        delete pxt;\\n        return err;\\n    }\\n    TestClass1 *pInstance = (TestClass1 *)pxt->UnWarpInstance();\\n\\n    struct if_direct_value_struct *vio = new if_direct_value_struct();\\n    \\n    pxt->SwapJs2CUtf8(pxt->GetArgv(0), vio->in0);\\n\\n    pInstance->if_direct(vio->in0, vio->out);\\n\\n    napi_value result = nullptr;\\n    result = pxt->SwapC2JsUtf8(vio->out.c_str());\\n\\n    delete vio;\\n    if (pxt->IsFailed()) {\\n        result = pxt->GetError();\\n    }\\n    delete pxt; // release\\n    return result;\\n}\\nstruct if_callback_value_struct {\\n    std::string in0;\\n    \\n    std::string out;\\n};\\n\\nstatic napi_value if_callback_middle(napi_env env, napi_callback_info info)\\n{\\n    XNapiTool *pxt = std::make_unique<XNapiTool>(env, info).release();\\n    if (pxt->IsFailed()) {\\n        napi_value err = pxt->GetError();\\n        delete pxt;\\n        return err;\\n    }\\n    TestClass1 *pInstance = (TestClass1 *)pxt->UnWarpInstance();\\n\\n    struct if_callback_value_struct *vio = new if_callback_value_struct();\\n    \\n    pxt->SwapJs2CUtf8(pxt->GetArgv(0), vio->in0);\\n\\n    pInstance->if_callback(vio->in0, vio->out);\\n\\n    napi_value result = nullptr;\\n    result = pxt->SwapC2JsUtf8(vio->out.c_str());\\n\\n    {\\n        napi_value args[1] = {result};\\n        pxt->SyncCallBack(pxt->GetArgv(1), 1, args);\\n    }\\n    result = pxt->UndefinedValue();\\n\\n    delete vio;\\n    if (pxt->IsFailed()) {\\n        result = pxt->GetError();\\n    }\\n    delete pxt; // release\\n    return result;\\n}\\nstruct if_async_value_struct {\\n    std::string in0;\\n    \\n    std::string out;\\n};\\n\\nstatic void if_async_execute(XNapiTool *pxt, void *data)\\n{\\n    if_async_value_struct *vio = (if_async_value_struct *)data;\\n    TestClass1 *pInstance = (TestClass1 *)pxt->GetAsyncInstance();\\n\\n    pInstance->if_async(vio->in0, vio->out);\\n}\\n\\nstatic void if_async_complete(XNapiTool *pxt, void *data)\\n{\\n    if_async_value_struct *vio = (if_async_value_struct *)data;\\n    \\n    napi_value result = nullptr;\\n    result = pxt->SwapC2JsUtf8(vio->out.c_str());\\n    \\n    {\\n        napi_value args[1] = {result};\\n        pxt->FinishAsync(1, args);\\n    }\\n\\n    delete vio;\\n}\\n\\nstatic napi_value if_async_middle(napi_env env, napi_callback_info info)\\n{\\n    XNapiTool *pxt = std::make_unique<XNapiTool>(env, info).release();\\n    if (pxt->IsFailed()) {\\n        napi_value err = pxt->GetError();\\n        delete pxt;\\n        return err;\\n    }\\n    pxt->SetAsyncInstance(pxt->UnWarpInstance());\\n\\n    struct if_async_value_struct *vio = new if_async_value_struct();\\n    \\n    pxt->SwapJs2CUtf8(pxt->GetArgv(0), vio->in0);\\n\\n    \\n    napi_value result = pxt->StartAsync(if_async_execute, vio, if_async_complete, pxt->GetArgc() == 2 ? pxt->GetArgv(1) : nullptr);\\n\\n    if (pxt->IsFailed()) {\\n        result = pxt->GetError();\\n    }\\n    return result;\\n}\\n};\\nstruct fun2_value_struct {\\n    std::string in0;\\n    std::vector<NUMBER_TYPE_4> in1;\\n    Human in2;\\n    \\n    std::vector<Human> out;\\n};\\n\\nnapi_value fun2_middle(napi_env env, napi_callback_info info)\\n{\\n    XNapiTool *pxt = std::make_unique<XNapiTool>(env, info).release();\\n    if (pxt->IsFailed()) {\\n        napi_value err = pxt->GetError();\\n        delete pxt;\\n        return err;\\n    }\\n    \\n\\n    struct fun2_value_struct *vio = new fun2_value_struct();\\n    \\n    pxt->SwapJs2CUtf8(pxt->GetArgv(0), vio->in0);    uint32_t len8=pxt->GetArrayLength(pxt->GetArgv(1));\\n    for(uint32_t i8=0;i8<len8;i8++) {\\n        NUMBER_TYPE_4 tt8;\\n        NUMBER_JS_2_C(pxt->GetArrayElement(pxt->GetArgv(1),i8),NUMBER_TYPE_4,tt8);\\n        vio->in1.push_back(tt8);\\n    }napi_value tnv9 = pxt->GetValueProperty(pxt->GetArgv(2), \\\"name\\\");\\n    if(tnv9!=nullptr){pxt->SwapJs2CUtf8(tnv9,vio->in2.name);}napi_value tnv10 = pxt->GetValueProperty(pxt->GetArgv(2), \\\"age\\\");\\n    if(tnv10!=nullptr){NUMBER_JS_2_C(tnv10,NUMBER_TYPE_1,vio->in2.age);}\\n\\n    fun2(vio->in0, vio->in1, vio->in2, vio->out);\\n\\n    napi_value result = nullptr;\\n    uint32_t len1=vio->out.size();\\n    for(uint32_t i=0;i<len1;i++) {\\n        napi_value tnv1 = nullptr;\\n        {\\nnapi_value tnv2 = nullptr;\\ntnv2 = pxt->SwapC2JsUtf8(vio->out[i].name.c_str());\\npxt->SetValueProperty(tnv1,\\\"name\\\",tnv2);\\n}{\\nnapi_value tnv2 = nullptr;\\ntnv2 = NUMBER_C_2_JS(pxt, vio->out[i].age);\\npxt->SetValueProperty(tnv1,\\\"age\\\",tnv2);\\n}\\n        pxt->SetArrayElement(result, i, tnv1);\\n    }\\n\\n    delete vio;\\n    if (pxt->IsFailed()) {\\n        result = pxt->GetError();\\n    }\\n    delete pxt; // release\\n    return result;\\n}\\nstruct fun3_value_struct {\\n    std::string in0;\\n    \\n    std::string out;\\n};\\n\\nnapi_value fun3_middle(napi_env env, napi_callback_info info)\\n{\\n    XNapiTool *pxt = std::make_unique<XNapiTool>(env, info).release();\\n    if (pxt->IsFailed()) {\\n        napi_value err = pxt->GetError();\\n        delete pxt;\\n        return err;\\n    }\\n    \\n\\n    struct fun3_value_struct *vio = new fun3_value_struct();\\n    \\n    pxt->SwapJs2CUtf8(pxt->GetArgv(0), vio->in0);\\n\\n    fun3(vio->in0, vio->out);\\n\\n    napi_value result = nullptr;\\n    result = pxt->SwapC2JsUtf8(vio->out.c_str());\\n\\n    {\\n        napi_value args[1] = {result};\\n        pxt->SyncCallBack(pxt->GetArgv(1), 1, args);\\n    }\\n    result = pxt->UndefinedValue();\\n\\n    delete vio;\\n    if (pxt->IsFailed()) {\\n        result = pxt->GetError();\\n    }\\n    delete pxt; // release\\n    return result;\\n}\\nstruct fun4_value_struct {\\n    std::string in0;\\n    \\n    std::string out;\\n};\\n\\nvoid fun4_execute(XNapiTool *pxt, void *data)\\n{\\n    fun4_value_struct *vio = (fun4_value_struct *)data;\\n    \\n\\n    fun4(vio->in0, vio->out);\\n}\\n\\nvoid fun4_complete(XNapiTool *pxt, void *data)\\n{\\n    fun4_value_struct *vio = (fun4_value_struct *)data;\\n    \\n    napi_value result = nullptr;\\n    result = pxt->SwapC2JsUtf8(vio->out.c_str());\\n    \\n    {\\n        napi_value args[1] = {result};\\n        pxt->FinishAsync(1, args);\\n    }\\n\\n    delete vio;\\n}\\n\\nnapi_value fun4_middle(napi_env env, napi_callback_info info)\\n{\\n    XNapiTool *pxt = std::make_unique<XNapiTool>(env, info).release();\\n    if (pxt->IsFailed()) {\\n        napi_value err = pxt->GetError();\\n        delete pxt;\\n        return err;\\n    }\\n    \\n\\n    struct fun4_value_struct *vio = new fun4_value_struct();\\n    \\n    pxt->SwapJs2CUtf8(pxt->GetArgv(0), vio->in0);\\n\\n    \\n    napi_value result = pxt->StartAsync(fun4_execute, vio, fun4_complete, pxt->GetArgc() == 2 ? pxt->GetArgv(1) : nullptr);\\n\\n    if (pxt->IsFailed()) {\\n        result = pxt->GetError();\\n    }\\n    return result;\\n}namespace Space3 {\\nclass TestClass2_middle {\\npublic:\\nstatic napi_value constructor(napi_env env, napi_callback_info info)\\n{\\n    XNapiTool *pxt = new XNapiTool(env, info);\\n\\n    TestClass2 *p = new TestClass2();\\n\\n    napi_value thisvar = pxt->WrapInstance(p, release);\\n\\n    return thisvar;\\n}\\nstatic void release(void *p)\\n{\\n    TestClass2 *p2 = (TestClass2 *)p;\\n    delete p2;\\n}\\n\\n    static napi_value getvalue_haha(napi_env env, napi_callback_info info)\\n    {\\n        XNapiTool *pxt = std::make_unique<XNapiTool>(env, info).release();\\n        TestClass2 *p = (TestClass2 *)pxt->UnWarpInstance();\\n        napi_value result;\\n        result = NUMBER_C_2_JS(pxt, p->haha);\\n        delete pxt;\\n        return result;\\n    }\\n    static napi_value setvalue_haha(napi_env env, napi_callback_info info)\\n    {\\n        std::shared_ptr<XNapiTool> pxt = std::make_shared<XNapiTool>(env, info);\\n        TestClass2 *p = (TestClass2 *)pxt->UnWarpInstance();\\n        NUMBER_JS_2_C(pxt->GetArgv(0),NUMBER_TYPE_5,p->haha);\\n        return nullptr;\\n    }\\n\\n};\\nstruct fun3_value_struct {\\n    std::string in0;\\n    \\n    std::string out;\\n};\\n\\nnapi_value fun3_middle(napi_env env, napi_callback_info info)\\n{\\n    XNapiTool *pxt = std::make_unique<XNapiTool>(env, info).release();\\n    if (pxt->IsFailed()) {\\n        napi_value err = pxt->GetError();\\n        delete pxt;\\n        return err;\\n    }\\n    \\n\\n    struct fun3_value_struct *vio = new fun3_value_struct();\\n    \\n    pxt->SwapJs2CUtf8(pxt->GetArgv(0), vio->in0);\\n\\n    fun3(vio->in0, vio->out);\\n\\n    napi_value result = nullptr;\\n    result = pxt->SwapC2JsUtf8(vio->out.c_str());\\n\\n    delete vio;\\n    if (pxt->IsFailed()) {\\n        result = pxt->GetError();\\n    }\\n    delete pxt; // release\\n    return result;\\n}namespace Space4 {\\nclass TestClass3_middle {\\npublic:\\nstatic napi_value constructor(napi_env env, napi_callback_info info)\\n{\\n    XNapiTool *pxt = new XNapiTool(env, info);\\n\\n    TestClass3 *p = new TestClass3();\\n\\n    napi_value thisvar = pxt->WrapInstance(p, release);\\n\\n    return thisvar;\\n}\\nstatic void release(void *p)\\n{\\n    TestClass3 *p2 = (TestClass3 *)p;\\n    delete p2;\\n}\\n\\n    static napi_value getvalue_hoho(napi_env env, napi_callback_info info)\\n    {\\n        XNapiTool *pxt = std::make_unique<XNapiTool>(env, info).release();\\n        TestClass3 *p = (TestClass3 *)pxt->UnWarpInstance();\\n        napi_value result;\\n        result = NUMBER_C_2_JS(pxt, p->hoho);\\n        delete pxt;\\n        return result;\\n    }\\n    static napi_value setvalue_hoho(napi_env env, napi_callback_info info)\\n    {\\n        std::shared_ptr<XNapiTool> pxt = std::make_shared<XNapiTool>(env, info);\\n        TestClass3 *p = (TestClass3 *)pxt->UnWarpInstance();\\n        NUMBER_JS_2_C(pxt->GetArgv(0),NUMBER_TYPE_6,p->hoho);\\n        return nullptr;\\n    }\\n\\nstruct add_value_struct {\\n    std::vector<NUMBER_TYPE_7> in0;\\n    \\n    NUMBER_TYPE_8 out;\\n};\\n\\nstatic napi_value add_middle(napi_env env, napi_callback_info info)\\n{\\n    XNapiTool *pxt = std::make_unique<XNapiTool>(env, info).release();\\n    if (pxt->IsFailed()) {\\n        napi_value err = pxt->GetError();\\n        delete pxt;\\n        return err;\\n    }\\n    TestClass3 *pInstance = (TestClass3 *)pxt->UnWarpInstance();\\n\\n    struct add_value_struct *vio = new add_value_struct();\\n    \\n        uint32_t len11=pxt->GetArrayLength(pxt->GetArgv(0));\\n    for(uint32_t i11=0;i11<len11;i11++) {\\n        NUMBER_TYPE_7 tt11;\\n        NUMBER_JS_2_C(pxt->GetArrayElement(pxt->GetArgv(0),i11),NUMBER_TYPE_7,tt11);\\n        vio->in0.push_back(tt11);\\n    }\\n\\n    pInstance->add(vio->in0, vio->out);\\n\\n    napi_value result = nullptr;\\n    result = NUMBER_C_2_JS(pxt, vio->out);\\n\\n    delete vio;\\n    if (pxt->IsFailed()) {\\n        result = pxt->GetError();\\n    }\\n    delete pxt; // release\\n    return result;\\n}\\n};\\nstruct fun3_value_struct {\\n    std::string in0;\\n    \\n    std::string out;\\n};\\n\\nnapi_value fun3_middle(napi_env env, napi_callback_info info)\\n{\\n    XNapiTool *pxt = std::make_unique<XNapiTool>(env, info).release();\\n    if (pxt->IsFailed()) {\\n        napi_value err = pxt->GetError();\\n        delete pxt;\\n        return err;\\n    }\\n    \\n\\n    struct fun3_value_struct *vio = new fun3_value_struct();\\n    \\n    pxt->SwapJs2CUtf8(pxt->GetArgv(0), vio->in0);\\n\\n    fun3(vio->in0, vio->out);\\n\\n    napi_value result = nullptr;\\n    result = pxt->SwapC2JsUtf8(vio->out.c_str());\\n\\n    delete vio;\\n    if (pxt->IsFailed()) {\\n        result = pxt->GetError();\\n    }\\n    delete pxt; // release\\n    return result;\\n}}}}\",\"middleInit\":\"{\\n    std::map<const char *,std::map<const char *,napi_callback>> valueList;\\n    valueList[\\\"name\\\"][\\\"getvalue\\\"]=napitest::Human_middle::getvalue_name;\\n    valueList[\\\"name\\\"][\\\"setvalue\\\"]=napitest::Human_middle::setvalue_name;\\n    valueList[\\\"age\\\"][\\\"getvalue\\\"]=napitest::Human_middle::getvalue_age;\\n    valueList[\\\"age\\\"][\\\"setvalue\\\"]=napitest::Human_middle::setvalue_age;\\n    std::map<const char *, napi_callback> funcList;\\n    pxt->DefineClass(\\\"Human\\\", napitest::Human_middle::constructor, valueList ,funcList);\\n}\\n{\\n    std::map<const char *,std::map<const char *,napi_callback>> valueList;\\n    valueList[\\\"ahuman\\\"][\\\"getvalue\\\"]=napitest::TestClass1_middle::getvalue_ahuman;\\n    valueList[\\\"ahuman\\\"][\\\"setvalue\\\"]=napitest::TestClass1_middle::setvalue_ahuman;\\n    valueList[\\\"num1\\\"][\\\"getvalue\\\"]=napitest::TestClass1_middle::getvalue_num1;\\n    valueList[\\\"num1\\\"][\\\"setvalue\\\"]=napitest::TestClass1_middle::setvalue_num1;\\n    valueList[\\\"str1\\\"][\\\"getvalue\\\"]=napitest::TestClass1_middle::getvalue_str1;\\n    valueList[\\\"str1\\\"][\\\"setvalue\\\"]=napitest::TestClass1_middle::setvalue_str1;\\n    valueList[\\\"nums\\\"][\\\"getvalue\\\"]=napitest::TestClass1_middle::getvalue_nums;\\n    valueList[\\\"nums\\\"][\\\"setvalue\\\"]=napitest::TestClass1_middle::setvalue_nums;\\n    valueList[\\\"strs\\\"][\\\"getvalue\\\"]=napitest::TestClass1_middle::getvalue_strs;\\n    valueList[\\\"strs\\\"][\\\"setvalue\\\"]=napitest::TestClass1_middle::setvalue_strs;\\n    valueList[\\\"mans\\\"][\\\"getvalue\\\"]=napitest::TestClass1_middle::getvalue_mans;\\n    valueList[\\\"mans\\\"][\\\"setvalue\\\"]=napitest::TestClass1_middle::setvalue_mans;\\n    std::map<const char *, napi_callback> funcList;\\n    funcList[\\\"if_direct\\\"] = napitest::TestClass1_middle::if_direct_middle;\\n    funcList[\\\"if_callback\\\"] = napitest::TestClass1_middle::if_callback_middle;\\n    funcList[\\\"if_async\\\"] = napitest::TestClass1_middle::if_async_middle;\\n    pxt->DefineClass(\\\"TestClass1\\\", napitest::TestClass1_middle::constructor, valueList ,funcList);\\n}\\n    pxt->DefineFunction(\\\"fun2\\\", napitest::fun2_middle);\\n    pxt->DefineFunction(\\\"fun3\\\", napitest::fun3_middle);\\n    pxt->DefineFunction(\\\"fun4\\\", napitest::fun4_middle);\\n{\\nnapi_value Space3=pxt->CreateSubObject(exports,\\\"Space3\\\");\\n{\\n    std::map<const char *,std::map<const char *,napi_callback>> valueList;\\n    valueList[\\\"haha\\\"][\\\"getvalue\\\"]=napitest::Space3::TestClass2_middle::getvalue_haha;\\n    valueList[\\\"haha\\\"][\\\"setvalue\\\"]=napitest::Space3::TestClass2_middle::setvalue_haha;\\n    std::map<const char *, napi_callback> funcList;\\n    pxt->DefineClass(\\\"TestClass2\\\", napitest::Space3::TestClass2_middle::constructor, valueList ,funcList, Space3);\\n}\\n    pxt->DefineFunction(\\\"fun3\\\", napitest::Space3::fun3_middle, Space3);\\n{\\nnapi_value Space4=pxt->CreateSubObject(Space3,\\\"Space4\\\");\\n{\\n    std::map<const char *,std::map<const char *,napi_callback>> valueList;\\n    valueList[\\\"hoho\\\"][\\\"getvalue\\\"]=napitest::Space3::Space4::TestClass3_middle::getvalue_hoho;\\n    valueList[\\\"hoho\\\"][\\\"setvalue\\\"]=napitest::Space3::Space4::TestClass3_middle::setvalue_hoho;\\n    std::map<const char *, napi_callback> funcList;\\n    funcList[\\\"add\\\"] = napitest::Space3::Space4::TestClass3_middle::add_middle;\\n    pxt->DefineClass(\\\"TestClass3\\\", napitest::Space3::Space4::TestClass3_middle::constructor, valueList ,funcList, Space4);\\n}\\n    pxt->DefineFunction(\\\"fun3\\\", napitest::Space3::Space4::fun3_middle, Space4);\\n}}\"}",
        "ParamGenerate": "{\"valueIn\":\"\\n    std::string in0;\",\"valueOut\":\"\",\"valueCheckout\":\"pxt->SwapJs2CUtf8(pxt->GetArgv(0), vio->in0);\",\"valueFill\":\"vio->in0\",\"valuePackage\":\"\",\"valueDefine\":\"std::string &a\"}",
        "returnGenerate": "{\"valueIn\":\"\",\"valueOut\":\"std::string out;\",\"valueCheckout\":\"\",\"valueFill\":\"vio->out\",\"valuePackage\":\"napi_value result = nullptr;\\n    result = pxt->SwapC2JsUtf8(vio->out.c_str());\",\"valueDefine\":\"std::string &out\"}"
    },
    "Generate1": {
        "ParamGenerate": "{\"valueIn\":\"\\n    NUMBER_TYPE_1 in0;\",\"valueOut\":\"\",\"valueCheckout\":\"NUMBER_JS_2_C(pxt->GetArgv(0),NUMBER_TYPE_1,vio->in0);\",\"valueFill\":\"vio->in0\",\"valuePackage\":\"\",\"valueDefine\":\"NUMBER_TYPE_1 &a\"}",
        "returnGenerate": "{\"valueIn\":\"\",\"valueOut\":\"NUMBER_TYPE_1 out;\",\"valueCheckout\":\"\",\"valueFill\":\"vio->out\",\"valuePackage\":\"napi_value result = nullptr;\\n    result = NUMBER_C_2_JS(pxt, vio->out);\",\"valueDefine\":\"NUMBER_TYPE_1 &out\"}"
    },
    "Generate2": {
        "returnGenerate": "{\"valueIn\":\"\",\"valueOut\":\"std::vector<std::string> out;\",\"valueCheckout\":\"\",\"valueFill\":\"vio->out\",\"valuePackage\":\"napi_value result = nullptr;\\n    uint32_t len1=vio->out.size();\\n    for(uint32_t i=0;i<len1;i++) {\\n        napi_value tnv1 = nullptr;\\n        tnv1 = pxt->SwapC2JsUtf8(vio->out[i].c_str());\\n        pxt->SetArrayElement(result, i, tnv1);\\n    }\",\"valueDefine\":\"std::vector<std::string> &out\"}",
        "ParamGenerate": "{\"valueIn\":\"\\n    std::vector<std::string> in0;\",\"valueOut\":\"\",\"valueCheckout\":\"    uint32_t len13=pxt->GetArrayLength(pxt->GetArgv(0));\\n    for(uint32_t i13=0;i13<len13;i13++) {\\n        std::string tt13;\\n        pxt->SwapJs2CUtf8(pxt->GetArrayElement(pxt->GetArgv(0),i13), tt13);\\n        vio->in0.push_back(tt13);\\n    }\",\"valueFill\":\"vio->in0\",\"valuePackage\":\"\",\"valueDefine\":\"std::vector<std::string> &a\"}"
    }
}